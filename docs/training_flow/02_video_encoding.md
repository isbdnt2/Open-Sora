# 02. 视频编码 (Video Encoding)

## 流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              视频编码流程                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          1. VAE 编码                                         │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   RGB 视频                              潜在表示                            │   │
│   │   video [B, 3, T, H, W]   VAE.encode    x_0 [B, 16, T', H', W']             │   │
│   │   [16, 3, 17, 256, 256]  ──────────►   [16, 16, 5, 32, 32]                  │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                      HunyuanVAE Encoder                             │   │   │
│   │   │                                                                     │   │   │
│   │   │   ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐       │   │   │
│   │   │   │ Conv3D  │ ──► │ ResBlk  │ ──► │DownSamp│ ──► │ ResBlk  │       │   │   │
│   │   │   │  In     │     │  ×2     │     │  ×3     │     │  ×2     │       │   │   │
│   │   │   └─────────┘     └─────────┘     └─────────┘     └─────────┘       │   │   │
│   │   │        │                                               │            │   │   │
│   │   │        └───────────────────┬───────────────────────────┘            │   │   │
│   │   │                            ▼                                        │   │   │
│   │   │                  ┌─────────────────┐                                │   │   │
│   │   │                  │   Conv3D Out    │                                │   │   │
│   │   │                  │   3 → 16 通道   │                                │   │   │
│   │   │                  └─────────────────┘                                │   │   │
│   │   │                                                                     │   │   │
│   │   │   压缩比:                                                           │   │   │
│   │   │   - 空间: 8x (256 → 32)                                             │   │   │
│   │   │   - 时间: 4x (17 → 5, Causal: (17-1)/4+1=5)                         │   │   │
│   │   │   - 通道: 3 → 16                                                    │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          2. I2V/V2V 条件准备                                 │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   根据 condition_config 随机选择条件类型:                                   │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │   condition_config = {                                              │   │   │
│   │   │       "t2v": 0.5,        # 纯文本生成 (无视觉条件)                  │   │   │
│   │   │       "i2v_head": 0.2,   # 首帧条件                                 │   │   │
│   │   │       "i2v_tail": 0.1,   # 尾帧条件                                 │   │   │
│   │   │       "i2v_loop": 0.1,   # 首尾帧条件                               │   │   │
│   │   │       "v2v_head": 0.05,  # 前 33 帧条件                             │   │   │
│   │   │       "v2v_tail": 0.05,  # 后 33 帧条件                             │   │   │
│   │   │   }                                                                 │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          3. Mask 和 Condition 构建                           │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   以 i2v_head (首帧条件) 为例:                                              │   │
│   │                                                                             │   │
│   │   时间轴:  [F0] [F1] [F2] [F3] [F4]   (5 个 latent frames)                  │   │
│   │                                                                             │   │
│   │   masks:   [ 1] [ 0] [ 0] [ 0] [ 0]   形状: [B, 1, T', H', W']              │   │
│   │              ↑                                                              │   │
│   │            条件帧                                                           │   │
│   │                                                                             │   │
│   │   latent:  [L0] [ 0] [ 0] [ 0] [ 0]   形状: [B, 16, T', H', W']             │   │
│   │              ↑                                                              │   │
│   │            单独编码的参考图像                                               │   │
│   │                                                                             │   │
│   │   cond = concat(masks, latent)        形状: [B, 17, T', H', W']             │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          4. Pack 操作                                        │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   将 5D 张量 pack 成序列:                                                   │   │
│   │                                                                             │   │
│   │   x_0  [B, 16, T', H', W']  pack   x_0  [B, N, 64]                          │   │
│   │   [16, 16, 5, 32, 32]      ─────►  [16, 5120, 64]                           │   │
│   │                                                                             │   │
│   │   cond [B, 17, T', H', W']  pack   cond [B, N, 68]                          │   │
│   │   [16, 17, 5, 32, 32]      ─────►  [16, 5120, 68]                           │   │
│   │                                                                             │   │
│   │   Pack 公式 (einops):                                                       │   │
│   │   "b c t (h ph) (w pw) -> b (t h w) (c ph pw)"                              │   │
│   │   其中 ph = pw = patch_size = 2                                             │   │
│   │                                                                             │   │
│   │   N = T' × (H'/2) × (W'/2) = 5 × 16 × 16 = 1280 (per sample)               │   │
│   │                              但 H'=32, W'=32, 所以 N = 5×16×16 = 1280       │   │
│   │   哦等等，H'/ph = 32/2 = 16, 所以 N = 5×16×16 = 1280                        │   │
│   │                                                                             │   │
│   │   C × ph × pw = 16 × 2 × 2 = 64 (每个 patch 的维度)                         │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 输入/输出规格

### VAE 编码

| 输入 | 形状 | 描述 |
|-----|------|------|
| `video` | `[B, 3, T, H, W]` | RGB 视频，值域 [-1, 1] |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `x_0` | `[B, 16, T', H', W']` | 潜在表示 |

### 条件准备 (I2V/V2V)

| 输入 | 形状 | 描述 |
|-----|------|------|
| `video` | `[B, 3, T, H, W]` | RGB 视频 |
| `condition_config` | `dict` | 条件类型概率配置 |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `x_0` | `[B, 16, T', H', W']` | 潜在表示 |
| `cond` | `[B, 17, T', H', W']` | 条件张量 (masks + latent) |

### Pack 操作

| 输入 | 形状 | 描述 |
|-----|------|------|
| `x_0` | `[B, 16, T', H', W']` | 潜在表示 |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `x_0` | `[B, N, 64]` | 打包后的序列 |

## 关键代码

### VAE 编码

```python
# 位置: scripts/diffusion/train.py - prepare_inputs()

@torch.no_grad()
def prepare_inputs(batch):
    x = batch.pop("video")  # [B, 3, T, H, W]
    
    # 有视觉条件时
    if cfg.get("condition_config", None) is not None:
        x_0, cond = prepare_visual_condition(x, cfg.condition_config, model_ae)
        cond = pack(cond, patch_size=2)  # [B, N, 68]
    else:
        # 纯 T2V 模式
        x_0 = model_ae.encode(x)  # [B, 16, T', H', W']
    
    # Pack x_0
    x_0 = pack(x_0, patch_size=2)  # [B, N, 64]
    
    return x_0, cond
```

### 条件准备 (Causal VAE 版本)

```python
# 位置: opensora/utils/train.py

def prepare_visual_condition_causal(
    x: torch.Tensor,           # [B, 3, T, H, W]
    condition_config: dict,    # {"i2v_head": 0.2, "t2v": 0.5, ...}
    model_ae: torch.nn.Module,
) -> tuple[torch.Tensor, torch.Tensor]:
    B = x.shape[0]
    C = 16  # VAE latent channels
    T, H, W = model_ae.get_latent_size(x.shape[-3:])  # [5, 32, 32]
    
    # 初始化
    masks = torch.zeros(B, 1, T, H, W, device=x.device, dtype=x.dtype)
    latent = torch.zeros(B, C, T, H, W, device=x.device, dtype=x.dtype)
    x_0 = torch.zeros(B, C, T, H, W, device=x.device, dtype=x.dtype)
    
    # 条件类型和权重
    mask_cond_options = list(condition_config.keys())
    mask_cond_weights = list(condition_config.values())
    
    for i in range(B):
        # 随机选择条件类型
        mask_cond = random.choices(mask_cond_options, weights=mask_cond_weights, k=1)[0]
        
        if mask_cond == "i2v_head":
            # 首帧条件
            masks[i, :, 0, :, :] = 1
            x_0[i] = model_ae.encode(x[i].unsqueeze(0))[0]
            # 单独编码第一帧图像
            latent[i, :, :1, :, :] = model_ae.encode(x[i, :, :1, :, :].unsqueeze(0))
            
        elif mask_cond == "i2v_tail":
            # 尾帧条件
            masks[i, :, -1, :, :] = 1
            x_0[i] = model_ae.encode(x[i].unsqueeze(0))[0]
            latent[i, :, -1:, :, :] = model_ae.encode(x[i, :, -1:, :, :].unsqueeze(0))
            
        elif mask_cond == "i2v_loop":
            # 首尾帧条件
            masks[i, :, 0, :, :] = 1
            masks[i, :, -1, :, :] = 1
            x_0[i] = model_ae.encode(x[i].unsqueeze(0))[0]
            latent[i, :, :1, :, :] = model_ae.encode(x[i, :, :1, :, :].unsqueeze(0))
            latent[i, :, -1:, :, :] = model_ae.encode(x[i, :, -1:, :, :].unsqueeze(0))
            
        elif "v2v_head" in mask_cond:
            # 前 N 帧条件 (视频续写)
            ref_t = 33 if "easy" not in mask_cond else 65
            conditioned_t = (ref_t - 1) // 4 + 1
            masks[i, :, :conditioned_t, :, :] = 1
            x_0[i] = model_ae.encode(x[i].unsqueeze(0))[0]
            latent[i, :, :conditioned_t, :, :] = model_ae.encode(
                x[i, :, :ref_t, :, :].unsqueeze(0)
            )
            
        else:  # "t2v"
            # 纯文本生成，无视觉条件
            x_0[i] = model_ae.encode(x[i].unsqueeze(0))[0]
    
    # masks 中为 1 的位置对应有条件的帧
    latent = masks * latent  # 将非条件位置清零
    cond = torch.cat((masks, latent), dim=1)  # [B, 17, T', H', W']
    
    return x_0, cond
```

### Pack 函数

```python
# 位置: opensora/utils/sampling.py

def pack(x: Tensor, patch_size: int = 2) -> Tensor:
    """将 5D 张量 pack 成 3D 序列
    
    Args:
        x: [B, C, T, H, W] 潜在表示
        patch_size: patch 大小 (默认 2)
    
    Returns:
        [B, N, C*patch_size^2] 打包后的序列
        其中 N = T * (H/patch_size) * (W/patch_size)
    """
    return rearrange(
        x,
        "b c t (h ph) (w pw) -> b (t h w) (c ph pw)",
        ph=patch_size,
        pw=patch_size,
    )
    # 例: [B, 16, 5, 32, 32] -> [B, 5*16*16, 16*2*2] = [B, 1280, 64]
```

## 条件类型详解

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              条件类型示意图                                          │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   1. T2V (Text-to-Video) - 纯文本生成                                               │
│   ───────────────────────────────────────                                           │
│                                                                                     │
│   masks:  [ 0] [ 0] [ 0] [ 0] [ 0]                                                  │
│   latent: [ 0] [ 0] [ 0] [ 0] [ 0]                                                  │
│           所有帧都需要生成                                                          │
│                                                                                     │
│   2. I2V_HEAD - 首帧条件 (Image-to-Video)                                           │
│   ─────────────────────────────────────────                                         │
│                                                                                     │
│   masks:  [ 1] [ 0] [ 0] [ 0] [ 0]                                                  │
│   latent: [img] [ 0] [ 0] [ 0] [ 0]                                                 │
│            ↑                                                                        │
│           给定首帧，生成后续帧                                                      │
│                                                                                     │
│   3. I2V_TAIL - 尾帧条件                                                            │
│   ──────────────────────                                                            │
│                                                                                     │
│   masks:  [ 0] [ 0] [ 0] [ 0] [ 1]                                                  │
│   latent: [ 0] [ 0] [ 0] [ 0] [img]                                                 │
│                               ↑                                                     │
│                              给定尾帧，生成前序帧                                    │
│                                                                                     │
│   4. I2V_LOOP - 首尾帧条件 (循环视频)                                               │
│   ───────────────────────────────────                                               │
│                                                                                     │
│   masks:  [ 1] [ 0] [ 0] [ 0] [ 1]                                                  │
│   latent: [img1][ 0] [ 0] [ 0] [img2]                                               │
│            ↑                    ↑                                                   │
│           首帧                 尾帧                                                 │
│           生成中间过渡帧，可形成循环                                                │
│                                                                                     │
│   5. V2V_HEAD - 视频续写 (给定前 N 帧)                                              │
│   ───────────────────────────────────                                               │
│                                                                                     │
│   masks:  [ 1] [ 1] [ 1] [ 0] [ 0] [ 0] [ 0] [ 0] [ 0]                              │
│   latent: [vid][vid][vid][ 0] [ 0] [ 0] [ 0] [ 0] [ 0]                              │
│            ↑───────↑                                                                │
│           给定前 33 帧 (9 个 latent frames)                                         │
│                                                                                     │
│   6. V2V_TAIL - 视频前推 (给定后 N 帧)                                              │
│   ───────────────────────────────────                                               │
│                                                                                     │
│   masks:  [ 0] [ 0] [ 0] [ 0] [ 0] [ 0] [ 1] [ 1] [ 1]                              │
│   latent: [ 0] [ 0] [ 0] [ 0] [ 0] [ 0] [vid][vid][vid]                             │
│                                          ↑───────↑                                  │
│                                         给定后 33 帧                                │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 防止信息泄漏

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         为什么条件图像要单独编码？                                   │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   问题: 如果直接使用完整视频编码的 latent 作为条件                                  │
│                                                                                     │
│   x_0 = VAE.encode([img1, frame2, frame3, ..., frameN])                             │
│   latent[:, :, 0] = x_0[:, :, 0]  # ❌ 错误！                                       │
│                                                                                     │
│   由于 VAE 是 3D 卷积，第一帧的 latent 会包含后续帧的信息！                         │
│   这会导致"信息泄漏"，模型可以通过条件帧直接获取答案。                              │
│                                                                                     │
│   正确做法: 单独编码条件帧                                                          │
│                                                                                     │
│   latent[:, :, :1] = VAE.encode([img1])  # ✅ 正确！                                │
│                                                                                     │
│   单独编码保证条件帧的 latent 只包含该帧的信息。                                    │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                                                                             │   │
│   │   完整视频编码:                                                             │   │
│   │   [F0] [F1] [F2] [F3] [F4]  →  Conv3D  →  [L0] [L1] [L2] [L3] [L4]         │   │
│   │    ↓↘  ↓↘  ↓↘  ↓↘                         ↗↓  ↗↓  ↗↓  ↗↓                   │   │
│   │   L0 包含 F0, F1 的信息 (时间卷积核 > 1)                                    │   │
│   │                                                                             │   │
│   │   单独编码:                                                                 │   │
│   │   [F0]          →  Conv3D  →  [L0_single]                                  │   │
│   │   L0_single 只包含 F0 的信息                                               │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 维度变换完整示例

以 256×256 分辨率、17 帧视频、batch size 16 为例：

```
1. 输入视频
   video: [16, 3, 17, 256, 256]
   (B=16, C=3, T=17, H=256, W=256)

2. VAE 编码
   x_0: [16, 16, 5, 32, 32]
   (B=16, C=16, T'=5, H'=32, W'=32)
   
   压缩统计:
   - 原始: 16 × 3 × 17 × 256 × 256 = 53,477,376 floats
   - Latent: 16 × 16 × 5 × 32 × 32 = 1,310,720 floats
   - 压缩比: 53,477,376 / 1,310,720 ≈ 41x

3. 条件构建 (i2v_head)
   masks: [16, 1, 5, 32, 32]   # 第一帧为 1
   latent: [16, 16, 5, 32, 32] # 第一帧有值
   cond: [16, 17, 5, 32, 32]   # concat

4. Pack
   x_0: [16, 1280, 64]
   (B=16, N=5×16×16=1280, C×ph×pw=16×2×2=64)
   
   cond: [16, 1280, 68]
   (B=16, N=1280, 17×2×2=68)
```
