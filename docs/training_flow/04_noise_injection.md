# 04. 噪声注入 (Noise Injection - Flow Matching)

## 流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Flow Matching 加噪流程                                  │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          1. 时间步采样                                       │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   采样标准正态分布，经 sigmoid 映射到 [0, 1]:                               │   │
│   │                                                                             │   │
│   │   z ~ N(0, 1)        sigmoid         t ∈ [0, 1]                             │   │
│   │   [B]              ──────────►       [B]                                    │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   t = σ(z) = 1 / (1 + exp(-z))                                      │   │   │
│   │   │                                                                     │   │   │
│   │   │   sigmoid 分布特点:                                                 │   │   │
│   │   │   - t 集中在 0.5 附近                                               │   │   │
│   │   │   - 两端 (0 和 1 附近) 采样较少                                     │   │   │
│   │   │   - 避免极端时间步的数值问题                                        │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          2. Time Shift (SD3 风格)                            │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   根据分辨率调整时间步分布:                                                 │   │
│   │                                                                             │   │
│   │   t_raw [B]          time_shift       t_shifted [B]                         │   │
│   │   [0.3, 0.7, ...]   ──────────►      [0.5, 0.85, ...]                       │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   shift_alpha 计算:                                                 │   │   │
│   │   │   ─────────────────                                                 │   │   │
│   │   │   pixels = H × W / 4  (patch 后的空间大小)                          │   │   │
│   │   │                                                                     │   │   │
│   │   │   shift_alpha = linear_interp(pixels)                               │   │   │
│   │   │   - 256px: shift_alpha ≈ 1                                          │   │   │
│   │   │   - 1024px: shift_alpha ≈ 3                                         │   │   │
│   │   │                                                                     │   │   │
│   │   │   temporal_factor = sqrt(T)  # 时间维度影响                         │   │   │
│   │   │   shift_alpha *= temporal_factor                                    │   │   │
│   │   │                                                                     │   │   │
│   │   │   time_shift 公式:                                                  │   │   │
│   │   │   ────────────────                                                  │   │   │
│   │   │   t_shifted = shift_alpha * t / (1 + (shift_alpha - 1) * t)        │   │   │
│   │   │                                                                     │   │   │
│   │   │   效果:                                                             │   │   │
│   │   │   - 高分辨率/长视频: 时间步偏向 1 (更多噪声)                        │   │   │
│   │   │   - 低分辨率/短视频: 时间步分布更均匀                               │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          3. 噪声采样                                         │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   从标准正态分布采样噪声:                                                   │   │
│   │                                                                             │   │
│   │   x_1 ~ N(0, I)                                                             │   │
│   │   形状: [B, N, 64]  (与 x_0 相同)                                           │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   x_1 = torch.randn_like(x_0, dtype=torch.float32)                  │   │   │
│   │   │   x_1 = x_1.to(device, dtype)  # 转换为 bf16/fp16                   │   │   │
│   │   │                                                                     │   │   │
│   │   │   注意: 噪声先在 float32 生成，再转换精度                           │   │   │
│   │   │   保证噪声的数值稳定性                                              │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          4. 线性插值 (加噪)                                  │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   Flow Matching 的核心: 数据和噪声之间的线性插值                            │   │
│   │                                                                             │   │
│   │   x_0 (数据)                        x_t (加噪后)                            │   │
│   │   x_1 (噪声)     线性插值           [B, N, 64]                              │   │
│   │   t (时间步)    ──────────►                                                 │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   Flow Matching 插值公式:                                           │   │   │
│   │   │   ─────────────────────────                                         │   │   │
│   │   │                                                                     │   │   │
│   │   │   定义 t_rev = 1 - t  (反转时间)                                    │   │   │
│   │   │                                                                     │   │   │
│   │   │   x_t = t_rev × x_0 + (1 - (1 - σ_min) × t_rev) × x_1               │   │   │
│   │   │                                                                     │   │   │
│   │   │   简化 (σ_min ≈ 0):                                                 │   │   │
│   │   │   x_t ≈ (1-t) × x_0 + t × x_1                                       │   │   │
│   │   │                                                                     │   │   │
│   │   │   t=0: x_t = x_0 (纯数据)                                           │   │   │
│   │   │   t=1: x_t = x_1 (纯噪声)                                           │   │   │
│   │   │                                                                     │   │   │
│   │   │   注意: 训练中 t 反转使用 (t_rev = 1 - t)                           │   │   │
│   │   │   推理从 t=1 到 t=0，训练需要匹配                                   │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   │   图示:                                                                     │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   x_0 (数据)                                    x_1 (噪声)          │   │   │
│   │   │   ●━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━●                  │   │   │
│   │   │   ├───────┼───────┼───────┼───────┼───────┼─────┤                   │   │   │
│   │   │   t=0    0.2     0.4     0.6     0.8     1.0   t=1                  │   │   │
│   │   │                                                                     │   │   │
│   │   │   训练时 t 从 sigmoid 采样，覆盖整条路径                            │   │   │
│   │   │   推理时从 t=1 逐步走到 t=0                                         │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          5. Velocity Target 计算                             │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   模型需要预测的目标 (Ground Truth):                                        │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   v_target = (1 - σ_min) × x_1 - x_0                                │   │   │
│   │   │                                                                     │   │   │
│   │   │   简化 (σ_min ≈ 0):                                                 │   │   │
│   │   │   v_target ≈ x_1 - x_0                                              │   │   │
│   │   │                                                                     │   │   │
│   │   │   物理意义:                                                         │   │   │
│   │   │   - v_target 是从数据到噪声的"速度向量"                             │   │   │
│   │   │   - 推理时反向使用: x_new = x_t - dt × v_pred                       │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   │   对比 DDPM:                                                                │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                                                                     │   │   │
│   │   │   DDPM:         模型预测噪声 ε                                      │   │   │
│   │   │   Flow Matching: 模型预测速度 v (更稳定，更灵活)                    │   │   │
│   │   │                                                                     │   │   │
│   │   │   MovieGen 风格的 v_target 定义更加通用                             │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 输入/输出规格

### 时间步采样

| 输入 | 形状 | 描述 |
|-----|------|------|
| `batch_size` | `int` | Batch 大小 |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `t` | `[B]` | 时间步，值域 [0, 1] |

### 加噪

| 输入 | 形状 | 描述 |
|-----|------|------|
| `x_0` | `[B, N, 64]` | 打包后的潜在表示 |
| `t` | `[B]` | 时间步 |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `x_t` | `[B, N, 64]` | 加噪后的输入 |
| `x_1` | `[B, N, 64]` | 纯噪声 (用于计算 target) |
| `v_target` | `[B, N, 64]` | Velocity 目标 |

## 关键代码

### 时间步采样与 Time Shift

```python
# 位置: scripts/diffusion/train.py - prepare_inputs()

# 时间步采样
t = torch.sigmoid(torch.randn((bs), device=device))  # [B]

# Time Shift (SD3 风格)
shift_alpha = get_res_lin_function()((x_0.shape[-1] * x_0.shape[-2]) // 4)
# 对于 256px: shift_alpha ≈ 1
# 对于 1024px: shift_alpha ≈ 3

# 加入时间维度影响
shift_alpha *= math.sqrt(x_0.shape[-3])  # sqrt(T)

# 应用 time shift
t = time_shift(shift_alpha, t).to(dtype)
```

### time_shift 函数

```python
# 位置: opensora/utils/sampling.py

def time_shift(mu: float, t: Tensor) -> Tensor:
    """SD3 风格的时间步偏移
    
    Args:
        mu: shift_alpha，越大偏移越明显
        t: 原始时间步 [B]
    
    Returns:
        偏移后的时间步 [B]
    """
    return mu * t / (1 + (mu - 1) * t)
```

### 分辨率线性函数

```python
# 位置: opensora/utils/sampling.py

def get_res_lin_function(
    min_res: int = 256,
    max_res: int = 1024,
    min_shift: float = 1.0,
    max_shift: float = 3.0,
) -> Callable:
    """返回根据分辨率计算 shift_alpha 的函数"""
    
    def linear_function(pixels: int) -> float:
        # 线性插值
        t = (pixels - min_res**2) / (max_res**2 - min_res**2)
        t = max(0, min(1, t))  # clamp to [0, 1]
        return min_shift + t * (max_shift - min_shift)
    
    return linear_function
```

### 加噪与 Target 计算

```python
# 位置: scripts/diffusion/train.py - prepare_inputs()

sigma_min = cfg.get("sigma_min", 1e-5)  # 默认 1e-5，近似为 0

# 采样噪声
x_1 = torch.randn_like(x_0, dtype=torch.float32).to(device, dtype)

# 时间反转
t_rev = 1 - t  # [B]

# Flow Matching 线性插值
# x_t = t_rev × x_0 + (1 - (1-σ_min) × t_rev) × x_1
x_t = t_rev[:, None, None] * x_0 + (1 - (1 - sigma_min) * t_rev[:, None, None]) * x_1

# 准备模型输入
inp["img"] = x_t
inp["timesteps"] = t.to(dtype)
inp["guidance"] = torch.full((bs,), cfg.get("guidance", 4), device=device, dtype=dtype)

# 在 run_iter 中计算 target
v_target = (1 - sigma_min) * x_1 - x_0  # MovieGen 风格
```

## Flow Matching vs DDPM

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                           Flow Matching vs DDPM                                      │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   ┌────────────────────────────────┬────────────────────────────────┐               │
│   │         DDPM                   │       Flow Matching            │               │
│   ├────────────────────────────────┼────────────────────────────────┤               │
│   │                                │                                │               │
│   │  加噪公式:                     │  加噪公式:                     │               │
│   │  x_t = √ᾱ_t × x_0 + √(1-ᾱ_t) × ε │  x_t = (1-t) × x_0 + t × x_1  │               │
│   │                                │                                │               │
│   │  预测目标:                     │  预测目标:                     │               │
│   │  ε (噪声)                      │  v = x_1 - x_0 (速度)          │               │
│   │                                │                                │               │
│   │  采样步数:                     │  采样步数:                     │               │
│   │  通常需要 50-1000 步           │  通常 20-50 步即可             │               │
│   │                                │                                │               │
│   │  调度器:                       │  调度器:                       │               │
│   │  复杂的 β schedule            │  简单的线性插值                │               │
│   │                                │                                │               │
│   │  优点:                         │  优点:                         │               │
│   │  - 理论成熟                    │  - 更简单                      │               │
│   │  - 广泛使用                    │  - 采样更快                    │               │
│   │                                │  - 灵活的 ODE 求解器          │               │
│   │                                │                                │               │
│   └────────────────────────────────┴────────────────────────────────┘               │
│                                                                                     │
│   Open-Sora 选择 Flow Matching 的原因:                                              │
│                                                                                     │
│   1. 采样效率: 20-50 步即可生成高质量视频                                           │
│   2. 训练稳定: velocity 预测比噪声预测更稳定                                        │
│   3. 灵活性: 可以使用各种 ODE 求解器 (Euler, Heun, DPM++)                           │
│   4. 与 Flux/SD3 架构兼容: 使用相同的训练范式                                       │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## Time Shift 可视化

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              Time Shift 效果                                         │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   shift_alpha = 1 (256px):                                                          │
│                                                                                     │
│   原始 t:    0.0   0.2   0.4   0.6   0.8   1.0                                      │
│   shifted:   0.0   0.2   0.4   0.6   0.8   1.0  (无变化)                            │
│                                                                                     │
│   ─────────────────────────────────────────────────────────────────────────         │
│                                                                                     │
│   shift_alpha = 3 (1024px):                                                         │
│                                                                                     │
│   原始 t:    0.0   0.2   0.4   0.6   0.8   1.0                                      │
│   shifted:   0.0   0.43  0.67  0.82  0.92  1.0  (偏向高噪声)                        │
│                                                                                     │
│   图示:                                                                             │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                                                                             │   │
│   │   1.0 ─┬─────────────────────────────────────────●─────●                    │   │
│   │        │                               ●───────●                            │   │
│   │   0.8 ─┤                        ●─────●                                     │   │
│   │        │                  ●────●                                            │   │
│   │   0.6 ─┤             ●───●                        shift_alpha=3             │   │
│   │        │         ●──●                                                       │   │
│   │   0.4 ─┤      ●─●                                                           │   │
│   │        │    ●●                                                              │   │
│   │   0.2 ─┤  ●●─────────────────────────────────── shift_alpha=1              │   │
│   │        │ ●                                                                  │   │
│   │   0.0 ─●───────┬───────┬───────┬───────┬───────┬                           │   │
│   │       0.0     0.2     0.4     0.6     0.8     1.0                           │   │
│   │                        原始 t                                               │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   解释:                                                                             │
│   - 高分辨率图像/长视频需要更多去噪步骤                                             │
│   - Time Shift 让模型在训练时更多地看到高噪声样本                                   │
│   - 推理时使用相同的 shift，保证训练-推理一致性                                     │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 维度变换完整示例

以 batch size 16、17 帧 256×256 视频为例：

```
1. 输入
   x_0: [16, 1280, 64]  (packed VAE latent)
   bs: 16

2. 时间步采样
   z: [16] ~ N(0, 1)
   t_raw = sigmoid(z): [16]  # e.g., [0.42, 0.67, 0.31, ...]

3. Time Shift
   pixels = 32 * 32 // 4 = 256
   shift_alpha = 1.0 * sqrt(5) ≈ 2.24
   t_shifted: [16]  # e.g., [0.61, 0.82, 0.47, ...]

4. 噪声采样
   x_1: [16, 1280, 64] ~ N(0, I)

5. 加噪
   t_rev = 1 - t_shifted: [16]
   x_t = t_rev × x_0 + (1 - (1-σ_min) × t_rev) × x_1
   x_t: [16, 1280, 64]

6. Velocity Target
   v_target = (1 - σ_min) × x_1 - x_0
   v_target: [16, 1280, 64]

模型输入:
- img (x_t): [16, 1280, 64]
- timesteps (t): [16]
- guidance: [16] (全为 4.0)

训练目标:
- v_target: [16, 1280, 64]
```
