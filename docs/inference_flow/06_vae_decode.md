# 06. VAE 解码输出视频 (VAE Decode)

## 流程图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              VAE 解码流程                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          1. Unpack 序列                                      │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   去噪后的序列                         重建的潜在表示                        │   │
│   │   x [B, N, C×patch²]       Unpack     x [B, C, T', H', W']                  │   │
│   │   [1, 5120, 64]           ───────►    [1, 16, 5, 32, 32]                    │   │
│   │                                                                             │   │
│   │   Unpack 操作 (einops):                                                     │   │
│   │   "b (t h w) (c ph pw) -> b c t (h ph) (w pw)"                              │   │
│   │                                                                             │   │
│   │   其中:                                                                     │   │
│   │   - t = num_frames = 5                                                      │   │
│   │   - h = height / compression / patch = 256 / 8 / 2 = 16                     │   │
│   │   - w = width / compression / patch = 256 / 8 / 2 = 16                      │   │
│   │   - ph = pw = patch_size = 2                                                │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          2. I2V 条件帧替换 (可选)                            │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   如果是 I2V 模式，用原始参考帧替换生成的条件帧:                            │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │  cond_type == "i2v_head":                                           │   │   │
│   │   │      x[:, :, 0] = references[0]  # 替换第一帧                       │   │   │
│   │   │                                                                     │   │   │
│   │   │  cond_type == "i2v_tail":                                           │   │   │
│   │   │      x[:, :, -1] = references[0]  # 替换最后一帧                    │   │   │
│   │   │                                                                     │   │   │
│   │   │  cond_type == "i2v_loop":                                           │   │   │
│   │   │      x[:, :, 0] = references[0]   # 替换第一帧                      │   │   │
│   │   │      x[:, :, -1] = references[1]  # 替换最后一帧                    │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   │   目的: 确保条件帧与原始参考图像完全一致，避免误差累积                      │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          3. VAE Decode                                       │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   潜在表示                            RGB 视频                              │   │
│   │   x [B, 16, T', H', W']   VAE.decode  video [B, 3, T, H, W]                 │   │
│   │   [1, 16, 5, 32, 32]     ──────────►  [1, 3, 17, 256, 256]                  │   │
│   │                                                                             │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │                      HunyuanVAE Decoder                             │   │   │
│   │   │                                                                     │   │   │
│   │   │   ┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐       │   │   │
│   │   │   │ Conv3D  │ ──► │ ResBlk  │ ──► │UpSample │ ──► │ ResBlk  │       │   │   │
│   │   │   │  In     │     │  ×2     │     │  ×2     │     │  ×2     │       │   │   │
│   │   │   └─────────┘     └─────────┘     └─────────┘     └─────────┘       │   │   │
│   │   │        │                                               │            │   │   │
│   │   │        └───────────────────┬───────────────────────────┘            │   │   │
│   │   │                            ▼                                        │   │   │
│   │   │                  ┌─────────────────┐                                │   │   │
│   │   │                  │    更多层...    │                                │   │   │
│   │   │                  │  时间上采样 4x  │                                │   │   │
│   │   │                  │  空间上采样 8x  │                                │   │   │
│   │   │                  └────────┬────────┘                                │   │   │
│   │   │                           ▼                                         │   │   │
│   │   │                  ┌─────────────────┐                                │   │   │
│   │   │                  │   Conv3D Out    │                                │   │   │
│   │   │                  │   16 → 3 通道   │                                │   │   │
│   │   │                  └─────────────────┘                                │   │   │
│   │   │                                                                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   │   Causal VAE 的时间压缩:                                                    │   │
│   │   - 输入: T' = 5 (VAE 潜在空间)                                             │   │
│   │   - 输出: T = (T' - 1) * 4 + 1 = 17 帧                                      │   │
│   │   - 第一帧单独处理 (因果卷积)                                               │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          4. 后处理                                           │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   video = video[:, :, :num_frames]  # 裁剪到目标帧数                        │   │
│   │                                                                             │   │
│   │   如果不是 Causal VAE，可能需要去除填充帧:                                  │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │  i2v_head: video = video[:, :, pad_len:]    # 去除开头填充          │   │   │
│   │   │  i2v_tail: video = video[:, :, :-pad_len]   # 去除结尾填充          │   │   │
│   │   │  i2v_loop: video = video[:, :, pad_len:-pad_len]  # 去除两端填充    │   │   │
│   │   │                                                                     │   │   │
│   │   │  pad_len = temporal_compression - 1 = 4 - 1 = 3                     │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │                          5. 保存输出                                         │   │
│   ├─────────────────────────────────────────────────────────────────────────────┤   │
│   │                                                                             │   │
│   │   video [B, 3, T, H, W]                                                     │   │
│   │   值域: [-1, 1] 或 [0, 1]                                                   │   │
│   │        │                                                                    │   │
│   │        ▼                                                                    │   │
│   │   ┌─────────────────────────────────────────────────────────────────────┐   │   │
│   │   │   process_and_save()                                                │   │   │
│   │   │                                                                     │   │   │
│   │   │   1. 值域映射: [-1, 1] → [0, 255]                                   │   │   │
│   │   │   2. 数据类型: float → uint8                                        │   │   │
│   │   │   3. 维度重排: [B, C, T, H, W] → [B, T, H, W, C]                    │   │   │
│   │   │   4. 保存为视频文件 (.mp4) 或图片 (.png)                            │   │   │
│   │   └─────────────────────────────────────────────────────────────────────┘   │   │
│   │                                                                             │   │
│   │   输出文件:                                                                 │   │
│   │   - 视频: outputs/video_256px/sample_0.mp4                                  │   │
│   │   - 图片: outputs/image_256px/sample_0.png                                  │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 输入/输出规格

### Unpack

| 输入 | 形状 | 描述 |
|-----|------|------|
| `x` | `[B, N, C×patch²]` | 去噪后的序列 |
| `height` | `int` | 目标高度 |
| `width` | `int` | 目标宽度 |
| `num_frames` | `int` | VAE 潜在空间的帧数 |
| `patch_size` | `int` | Patch 大小（默认 2） |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `x` | `[B, C, T', H', W']` | 潜在表示 |

### VAE Decode

| 输入 | 形状 | 描述 |
|-----|------|------|
| `x` | `[B, 16, T', H', W']` | 潜在表示 |

| 输出 | 形状 | 描述 |
|-----|------|------|
| `video` | `[B, 3, T, H, W]` | RGB 视频 |

### 压缩比

| 维度 | 压缩比 | 说明 |
|------|--------|------|
| 空间 (H, W) | 8x | 256 → 32 |
| 时间 (T) | 4x | 17 → 5 (Causal VAE: (17-1)/4+1=5) |
| 通道 (C) | 5.3x | 3 → 16 (但空间压缩补偿) |

## 关键代码

### Unpack 函数

```python
# 位置: opensora/utils/sampling.py

def unpack(x: Tensor, height: int, width: int, num_frames: int, patch_size: int = 2) -> Tensor:
    """将 3D 序列 unpack 回 5D 张量"""
    D = int(os.environ.get("AE_SPATIAL_COMPRESSION", 16))  # 空间压缩比
    return rearrange(
        x,
        "b (t h w) (c ph pw) -> b c t (h ph) (w pw)",
        h=math.ceil(height / D),   # 32 (for 256px)
        w=math.ceil(width / D),    # 32 (for 256px)
        t=num_frames,              # 5 (VAE latent frames)
        ph=patch_size,             # 2
        pw=patch_size,             # 2
    )
    # 输入: [1, 5120, 64]
    # 输出: [1, 16, 5, 32, 32]
```

### VAE Decode

```python
# 位置: opensora/utils/sampling.py - api_fn()

# ... 去噪循环完成后 ...

# Unpack
x = unpack(x, opt.height, opt.width, num_frames, patch_size=patch_size)

# I2V 条件帧替换
if cond_type == "i2v_head":
    x[0, :, :1] = references[0][0]  # 第一帧
elif cond_type == "i2v_tail":
    x[0, :, -1:] = references[0][0]  # 最后一帧
elif cond_type == "i2v_loop":
    x[0, :, :1] = references[0][0]   # 第一帧
    x[0, :, -1:] = references[0][1]  # 最后一帧

# VAE 解码
x = model_ae.decode(x)
# 输入: [1, 16, 5, 32, 32]
# 输出: [1, 3, 17, 256, 256]

# 裁剪到目标帧数
x = x[:, :, :opt.num_frames]

# 去除填充帧 (非 Causal VAE)
if not opt.is_causal_vae:
    if cond_type == "i2v_head":
        pad_len = model_ae.compression[0] - 1  # 3
        x = x[:, :, pad_len:]
    elif cond_type == "i2v_tail":
        x = x[:, :, :-pad_len]
    elif cond_type == "i2v_loop":
        x = x[:, :, pad_len:-pad_len]

return x
```

### HunyuanVAE 配置

```python
# 位置: 配置文件

ae = dict(
    type="hunyuan_vae",
    from_pretrained="./ckpts/hunyuan_vae.safetensors",
    in_channels=3,         # RGB 输入
    out_channels=3,        # RGB 输出
    layers_per_block=2,    # 每个残差块的层数
    latent_channels=16,    # 潜在空间通道数
    use_spatial_tiling=True,   # 空间分块处理 (高分辨率)
    use_temporal_tiling=False, # 时间分块处理 (长视频)
)
is_causal_vae = True  # 使用因果卷积 VAE
```

## Causal VAE vs Standard VAE

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                         Causal VAE vs Standard VAE                                   │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   Standard VAE (双向):                                                              │
│   ────────────────────                                                              │
│                                                                                     │
│   时间轴:  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]                                  │
│                    ↓                                                                │
│            [  Conv3D (kernel=4, stride=4)  ]                                        │
│                    ↓                                                                │
│   潜在:    [        A        ] [        B        ]                                  │
│                                                                                     │
│   - 每 4 帧压缩为 1 个 latent frame                                                │
│   - 需要填充: 输入 17 帧 → 填充到 20 帧 → 输出 5 latent frames                     │
│                                                                                     │
│   Causal VAE (因果):                                                                │
│   ──────────────────                                                                │
│                                                                                     │
│   时间轴:  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9] ... [17]                    │
│             ↓       └──┴──┴──┘       └──┴──┴──┘                                     │
│            [1]         [2]              [3]        ...    [5]                       │
│                                                                                     │
│   - 第一帧单独编码 (保留完整信息)                                                  │
│   - 后续每 4 帧压缩为 1 个 latent frame                                            │
│   - 公式: T' = (T - 1) / 4 + 1                                                     │
│   - 例: 17 帧 → (17-1)/4+1 = 5 latent frames                                       │
│                                                                                     │
│   优势:                                                                             │
│   - 第一帧可以作为高质量的图像条件                                                 │
│   - 不需要填充，计算效率更高                                                       │
│   - 更好的时序一致性（因果关系）                                                   │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## Spatial Tiling (空间分块)

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              空间分块处理                                            │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│   用于高分辨率视频，避免显存溢出                                                    │
│                                                                                     │
│   ┌─────────────────────────────────────────────────────────────────────────────┐   │
│   │   原始高分辨率图像 (1024 × 1024)                                            │   │
│   │                                                                             │   │
│   │   ┌─────────────┬─────────────┐                                             │   │
│   │   │             │             │                                             │   │
│   │   │   Tile 1    │   Tile 2    │                                             │   │
│   │   │  (512×512)  │  (512×512)  │                                             │   │
│   │   │             │             │                                             │   │
│   │   ├─────────────┼─────────────┤                                             │   │
│   │   │             │             │                                             │   │
│   │   │   Tile 3    │   Tile 4    │                                             │   │
│   │   │  (512×512)  │  (512×512)  │                                             │   │
│   │   │             │             │                                             │   │
│   │   └─────────────┴─────────────┘                                             │   │
│   │                                                                             │   │
│   │   处理流程:                                                                 │   │
│   │   1. 分割成 4 个 512×512 的 tile                                            │   │
│   │   2. 每个 tile 独立通过 VAE encoder/decoder                                 │   │
│   │   3. 在边界处使用 overlap 和 blending 消除接缝                              │   │
│   │   4. 合并回完整图像                                                         │   │
│   │                                                                             │   │
│   └─────────────────────────────────────────────────────────────────────────────┘   │
│                                                                                     │
│   配置: use_spatial_tiling=True                                                     │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

## 维度变换完整示例

以 256×256 分辨率、17 帧视频为例：

```
1. 去噪后的序列
   x: [1, 5120, 64]
   (B=1, N=5×32×32=5120, C×patch²=16×4=64)

2. Unpack
   x: [1, 16, 5, 32, 32]
   (B=1, C=16, T'=5, H'=32, W'=32)

3. I2V 条件帧替换 (i2v_head)
   x[:, :, 0] = reference  # 第一个 latent frame

4. VAE Decode
   video: [1, 3, 17, 256, 256]
   (B=1, C=3, T=17, H=256, W=256)

5. 后处理
   - 值域映射: [-1, 1] → [0, 255]
   - 保存为 MP4

压缩统计:
- 原始视频: 1 × 3 × 17 × 256 × 256 = 3,342,336 floats
- 潜在表示: 1 × 16 × 5 × 32 × 32 = 81,920 floats
- 压缩比: 3,342,336 / 81,920 ≈ 41x
```
